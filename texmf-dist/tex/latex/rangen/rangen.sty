%%
%% This is file `rangen.sty',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% rangen.dtx  (with options: `copyright,package')
%% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Rangen.sty package,                       2016-02-19 %%
%% Copyright (C) 1999-2016  D. P. Story                 %%
%%   dpstory@uakron.edu                                 %%
%%                                                      %%
%% This program can redistributed and/or modified under %%
%% the terms of the LaTeX Project Public License        %%
%% Distributed from CTAN archives in directory          %%
%% macros/latex/base/lppl.txt; either version 1 of the  %%
%% License, or (at your option) any later version.      %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\NeedsTeXFormat{LaTeX2e}[1997/12/01]
\ProvidesPackage{rangen}
 [2014/10/17 v1.4 Rangen: Generate Random Questions (dps)]
\newcount\seedCnt
\DeclareOption{testmode}{%
    \InputIfFileExists{\jobname.seed}{}{\def\thisseed{1}}%
    \PassOptionsToPackage{seed=\thisseed}{lcg}%
    \AtEndOfPackage{\reseedEachRun}%
}
\def\reseedEachRun{%
    \seedCnt=\thisseed
    \advance\seedCnt1\relax
    \newwrite \rngWrite
    \immediate\openout\rngWrite \jobname.seed
    \immediate\write\rngWrite{\string\def\string\thisseed{\the\seedCnt}}
    \immediate\closeout\rngWrite
}
\def\RNG@Dec{.}
\DeclareOption*{\PassOptionsToPackage{\CurrentOption}{lcg}}
\ProcessOptions
\RequirePackage{lcg}[2008/09/10]
\edef\rng@saveSeed{\the\cr@nd}
\newcount\loopCnt
\def\maxLoopLimit{10}
\def\typeCodeForz{0}
\def\typeCodeForq{1}
\def\typeCodeForr{2}
\newcount\rng@cnta
\newcount\rng@cntb
\def\@getVarName#1{%
    \edef\@varName{\expandafter\@gobble\string#1}%
}
\def\@getVarType#1{%
    \@getVarName{#1}\edef\varType{\csname typeof@\@varName\endcsname}}
\def\gcd#1#2{{% #1 = a, #2 = b
    \ifnum#2=0 \edef\next{#1}\else
        \@tempcnta=#1 \@tempcntb=#2 \divide\@tempcnta by\@tempcntb
        \multiply\@tempcnta by\@tempcntb  % q*b
        \@tempcntb=#1
        \advance\@tempcntb by-\@tempcnta % remainder in \@tempcntb
        \ifnum\@tempcntb=0
            \@tempcnta=#2
            \ifnum\@tempcnta < 0 \@tempcnta=-\@tempcnta\fi
            \xdef\gcd@next{\noexpand%
                \def\noexpand\thegcd{\the\@tempcnta}}%
        \else
            \xdef\gcd@next{\noexpand\gcd{#2}{\the\@tempcntb}}%
        \fi
    \fi}\gcd@next
}
\def\lcm#1#2{% #1 = a, #2 = b
    \gcd{#1}{#2}%
    {\@tempcnta=#1
    \multiply\@tempcnta by#2
    \divide\@tempcnta by\thegcd
    \xdef\thelcm{\the\@tempcnta}}%
}
\def\amodb#1#2{% #1 = a, #2 = b
    {\@tempcnta=#1
    \divide\@tempcnta by#2
    \multiply\@tempcnta by#2
    \@tempcntb=#1
    \advance\@tempcntb by-\@tempcnta
    \xdef\retnmod{\the\@tempcntb}}%
}
\newcommand\reduceFrac[2]
{%
    \gcd{#1}{#2}{\@tempcnta=#1 \divide\@tempcnta by\thegcd
    \@tempcntb=#2 \divide\@tempcntb by\thegcd
    \ifnum\@tempcntb<0\relax
        \@tempcntb=-\@tempcntb
        \@tempcnta=-\@tempcnta
    \fi
    \xdef\rfNumer{\the\@tempcnta}\xdef\rfDenom{\the\@tempcntb}}%
}
\def\convertRatTo#1#2#3{{%
    \@tempcnta=#3
    \multiply\@tempcnta by#1
    \divide\@tempcnta by#2
    \xdef\rng@retn@num{\the\@tempcnta}%
}}
\newcommand\RNGadd[2]{%
    \rng@cnta=\nOf#1 \multiply\rng@cnta by\dOf#2
    \rng@cntb=\nOf#2 \multiply\rng@cntb by\dOf#1
    \advance\rng@cnta by\the\rng@cntb
    \rng@cntb=\dOf#1 \multiply\rng@cntb by\dOf#2
    \reduceFrac{\the\rng@cnta}{\the\rng@cntb}
}
\def\rng@isControl#1{\@ifundefined{\expandafter\@gobble\string#1}%
    {\let\rng@isC@ntrol=0}{\let\rng@isC@ntrol=1}}
\def\rng@existStar#1{\rng@existSt@r#1**\@nil}
\def\rng@existSt@r#1*#2*#3\@nil{\def\rng@isStari{#1}%
    \def\rng@isStarii{#2}\def\rng@isStariii{#3}%
}
\def\rng@NameEndpoint#1{%
    \ifx\rng@isStari\@empty
        \edef#1{\expandafter\noexpand\rng@isStarii}%
    \else\ifx\rng@isStarii\@empty
        \edef#1{\expandafter\noexpand\rng@isStari}%
    \fi\fi
}
\newcommand\defineZ[2]
{%
    \@getVarName#1\relax
    \expandafter\def\csname typeof@\@varName\endcsname{0}%
    \expandafter\edef\csname n@\@varName\endcsname{#2}%
    \expandafter\edef\csname d@\@varName\endcsname{1}%
    \edef\display@TeXfmt{#2}\edef\inline@TeXfmt{#2}%
    \ifnum#2=1\relax\rng@makeOneFmtDefns
    \else\ifnum#2=-1\relax\rng@makeMinusOneFmtDefns
    \else\rng@makeOtherFmtDefns\fi\fi
    \expandafter\let\csname\@varName*\endcsname\display@TeXfmt
    \expandafter\let\csname\@varName!\endcsname\inline@TeXfmt
    \expandafter\edef\csname\@varName\endcsname{#2}%
}
\newcommand\defineQ[3]
{%
    \@getVarName#1\relax
    \expandafter\def\csname typeof@\@varName\endcsname{1}%
    \expandafter\edef\csname n@\@varName\endcsname{#2}%
    \expandafter\edef\csname d@\@varName\endcsname{#3}%
    \edef\display@TeXfmt{\frac{#2}{#3}}\edef\inline@TeXfmt{#2/#3}%
    \ifnum#2=#3\relax\rng@makeOneFmtDefns
    \else\ifnum#2=-#3\relax\rng@makeMinusOneFmtDefns
    \else\rng@makeOtherFmtDefns\fi\fi
    \expandafter\let\csname\@varName*\endcsname\display@TeXfmt
    \expandafter\let\csname\@varName!\endcsname\inline@TeXfmt
    \expandafter\edef\csname\@varName\endcsname{#2/#3}%
    \simplifyCurrentQ
}
\newcommand{\defineR}[2]{%
    \@getVarName{#1}\RNGparseDec{#2}%
    \expandafter\def\csname typeof@\@varName\endcsname{2}%
    \reduceFrac{\rng@intpart\rng@fracpart}{\rndPower}%
    \expandafter\edef\csname n@\@varName\endcsname{\rfNumer}%
    \expandafter\edef\csname d@\@varName\endcsname{\rfDenom}%
    \edef\display@TeXfmt{#2}\edef\inline@TeXfmt{#2}%
    \ifnum\rfNumer=1\relax\rng@makeOneFmtDefns
    \else\ifnum\rfNumer=-1\relax\rng@makeMinusOneFmtDefns
    \else\rng@makeOtherFmtDefns\fi\fi
    \expandafter\let\csname\@varName*\endcsname\display@TeXfmt
    \expandafter\let\csname\@varName!\endcsname\inline@TeXfmt
    \expandafter\edef\csname\@varName\endcsname{#2}%
    \simplifyCurrentR
}
\newcommand{\simplifyCurrentR}{%
    \ifnum\csname d@\@varName\endcsname=1
    \expandafter\defineZ
    \csname\@varName\endcsname{\csname n@\@varName\endcsname}\fi
}
\def\rng@makeOneFmtDefns{%
    \expandafter\def\csname\@varName!e\endcsname{}%
    \expandafter\def\csname\@varName!c\endcsname{}%
    \expandafter\def\csname\@varName*e\endcsname{}%
    \expandafter\def\csname\@varName*c\endcsname{}%
}
\def\rng@makeMinusOneFmtDefns{%
    \expandafter\def\csname\@varName!e\endcsname{-1}%
    \expandafter\def\csname\@varName!c\endcsname{-}%
    \expandafter\def\csname\@varName*e\endcsname{-1}%
    \expandafter\def\csname\@varName*c\endcsname{-}%
}
\def\rng@makeOtherFmtDefns{%
    \expandafter\let\csname\@varName!e\endcsname\inline@TeXfmt
    \expandafter\let\csname\@varName!c\endcsname\inline@TeXfmt
    \expandafter\let\csname\@varName*e\endcsname\display@TeXfmt
    \expandafter\let\csname\@varName*c\endcsname\display@TeXfmt
}
\def\RNGparseRat#1{\expandafter\@chkslash#1//\@nil}
\def\@chkslash#1/#2/#3\@nil{%
    \def\rng@num{#1}\def\rng@denom{#2}%
    \def\rng@parseQ@iii{#3}%
    \ifx\rng@denom\@empty\def\rng@denom{1}\fi
}
\newcommand{\RNGparseDec}[1]{\edef\parse@argi{#1}%
    \expandafter\@chkdec\parse@argi..\@nil}
\def\@chkdec#1.#2.#3\@nil{%
    \def\rng@intpart{#1}\def\rng@fracpart{#2}%
    \def\rng@parseR@iii{#3}\rng@getnDec}
\def\rng@getnDec{%
    \begingroup
        \ifx\rng@fracpart\@empty\gdef\rndnDec{0}\gdef\rndPower{1}\else
        \count0=0\relax\count2=1\relax
        \expandafter\cntNumDec\rng@fracpart\end\fi
    \endgroup}
\def\cntNumDec#1#2\end{%
    \advance\count0by1
    \def\rng@arg{#2}%
    \ifx\rng@arg\@empty
        \xdef\rndnDec{\the\count0}%
        \xdef\rndPower{1\@nameuse{rng@tz\the\count0}}%
        \let\rng@next\relax
    \else
        \def\rng@next{\cntNumDec#2\end}%
    \fi\rng@next
}
\newcommand{\nDivisionsPowerOfTen}[1]{%
    \begingroup
    \count0=#1\relax
    \ifnum\count0>4\relax
        \PackageError{rangen}{Number of subdivisions too large}%
        {Reduce the argument of \string\nDivisionsPowerOfTen.}%
    \else
        \ifnum\count0<1\relax
        \PackageError{rangen}{Number of subdivisions too large}%
        {Increase the argument of \string\nDivisionsPowerOfTen.}%
    \fi\fi
    \xdef\RNGpowerOfTen{1\@nameuse{rng@tz#1}}%
    \endgroup
}
\nDivisionsPowerOfTen{2}
\newcommand\RandomZ[4][]
{%
    \def\rng@ne@values{}%
    \setkeys{rangen}{ne,#1}%
    \let\rng@CtrlLEP=0\let\rng@CtrlUEP=0%
    \let\rng@makeLEPStrict=0\let\rng@makeUEPStrict=0%
    \rng@existStar{#3}\rng@NameEndpoint{\rng@LEP}%
    \if\rng@isStariii*\edef\tmp@exp{%
        \noexpand\rng@isControl{\expandafter\noexpand\rng@LEP}}\tmp@exp
        \if\rng@isC@ntrol1% a control sequence
            \let\rng@CtrlLEP=1\let\rng@makeLEPStrict=1%
            \edef\tmp@exp{\noexpand%
                \@getVarType{\expandafter\noexpand\rng@LEP}}\tmp@exp
            \ifcase\varType % integer
                \rng@cnta=\rng@LEP
            \or % rational
                \rng@dima=\expandafter\nOf\rng@LEP pt
                \divide\rng@dima by\expandafter\dOf\rng@LEP
                \defineR{\rng@LEP}{\strip@pt\rng@dima}%
                \RNGparseDec{\rng@LEP}%
                \rng@cnta=\rng@intpart
            \or % real
                \defineR{\rng@LEP}{\rng@LEP}%
                \RNGparseDec{\rng@LEP}%
                \rng@cnta=\rng@intpart
            \fi
            \advance\rng@cnta by1\relax
            \defineZ{\rng@LEP}{\the\rng@cnta}%
        \else
            \defineZ{\rng@LEP}{\rng@LEP}%
        \fi
    \else
        \rng@isControl{#3}%
        \if\rng@isC@ntrol1% control sequence
            \let\rng@CtrlLEP=1%
            \def\rng@LEP{#3}%
            \@getVarType{#3}%
            \ifcase\varType % integer
                \defineZ{\rng@LEP}{#3}%
            \or % rational
                \rng@dima=\nOf{#3}pt
                \divide\rng@dima by\dOf{#3}%
                \defineR{\rng@LEP}{\strip@pt\rng@dima}%
                \RNGparseDec{\rng@LEP}%
                \defineZ{\rng@LEP}{\rng@intpart}%
            \or % real
                \defineR{\rng@LEP}{\rng@LEP}%
                \RNGparseDec{\rng@LEP}%
                \defineZ{\rng@LEP}{\rng@intpart}%
            \fi
        \else
            \defineZ{\rng@LEP}{#3}%
        \fi
    \fi
    \rng@existStar{#4}\rng@NameEndpoint{\rng@UEP}%
    \if\rng@isStariii*\edef\tmp@exp{%
        \noexpand\rng@isControl{\expandafter\noexpand\rng@UEP}}\tmp@exp
        \if\rng@isC@ntrol1% a control sequence
            \let\rng@CtrlUEP=1\let\rng@makeUEPStrict=1%
            \edef\tmp@exp{\noexpand%
                \@getVarType{\expandafter\noexpand\rng@UEP}}\tmp@exp
            \ifcase\varType % integer
                \rng@cnta=\rng@UEP
            \or % rational
                \rng@dima=\expandafter\nOf\rng@UEP pt
                \divide\rng@dima by\expandafter\dOf\rng@UEP
                \defineR{\rng@UEP}{\strip@pt\rng@dima}%
                \RNGparseDec{\rng@UEP}%
                \rng@cnta=\rng@intpart
            \or % real
                \defineR{\rng@UEP}{\rng@UEP}%
                \RNGparseDec{\rng@UEP}%
                \rng@cnta=\rng@intpart
            \fi
            \advance\rng@cnta by-1\relax
            \defineZ{\rng@UEP}{\the\rng@cnta}%
        \else
            \defineZ{\rng@UEP}{\rng@UEP}%
        \fi
    \else
        \rng@isControl{#4}%
        \if\rng@isC@ntrol1% control sequence
            \let\rng@CtrlUEP=1%
            \def\rng@UEP{#4}%
            \@getVarType{#4}%
            \ifcase\varType % integer
                \defineZ{\rng@UEP}{#4}%
            \or % rational
                \rng@dima=\nOf{#4}pt
                \divide\rng@dima by\dOf{#4}%
                \defineR{\rng@UEP}{\strip@pt\rng@dima}%
                \RNGparseDec{\rng@UEP}%
                \defineZ{\rng@UEP}{\rng@intpart}%
            \or % real
                \defineR{\rng@UEP}{\rng@UEP}%
                \RNGparseDec{\rng@UEP}%
                \defineZ{\rng@UEP}{\rng@intpart}%
            \fi
        \else
            \defineZ{\rng@UEP}{#4}%
        \fi
    \fi
    \def\@currentName{#2}%
    \@getVarName{#2}%
    \expandafter\def\csname typeof@\@varName\endcsname{0}%
    \expandafter\edef\csname first@\@varName\endcsname{\rng@LEP}%
    \expandafter\edef\csname last@\@varName\endcsname{\rng@UEP}%
    \rng@chgrand[first=\rng@LEP,last=\rng@UEP]\rand
    \defineZ{#2}{\arabic{rand}}%
    \ifx\rangen@ne\@empty\else\loopCnt=0\relax
        \@whilenum\loopCnt<\maxLoopLimit\do{%
            \rng@cnta=1\relax
            \@for\ne@@tmp:=\rangen@ne\do{%
                \ifnum\value{rand}=\ne@@tmp\relax
                    \multiply\rng@cnta0\relax
                \else
                    \multiply\rng@cnta1\relax
                \fi
            }%
            \ifnum\rng@cnta=1\relax % all conditions met
                \loopCnt=\maxLoopLimit
            \else % if \rng@cnta \ne 1, try again
                \advance\loopCnt1\relax
                \ifnum\loopCnt=\maxLoopLimit
                    \PackageWarning{rangen}{Not all conditions met
                        after \maxLoopLimit\space tries}%
                \else
                    \rng@chgrand[first=\rng@LEP,last=\rng@UEP]\rand
                \fi
            \fi
        }%
    \fi
    \defineZ{#2}{\arabic{rand}}%
}
\def\updateZ#1#2{%
    \@getVarName#1\relax
    \expandafter\edef\csname\@varName\endcsname{#2}%
    \expandafter\edef\csname n@\@varName\endcsname{#2}%
    \expandafter\edef\csname d@\@varName\endcsname{1}%
}
\newcommand{\RandomQ}[2][]
{%
    \setkeys{rangen}{ne,#1}%
    \def\rq@currentName{#2}%
    \@RandomQ
}
\newcommand{\@RandomQ}[3][]
{%
    \let\rng@CtrlLEP=0\let\rng@CtrlUEP=0%
    \let\rng@makeLEPStrict=0\let\rng@makeUEPStrict=0%
    \rng@existStar{#2}\rng@NameEndpoint{\rng@LEP}%
    \if\rng@isStariii*\edef\tmp@exp{\noexpand%
            \rng@isControl{\expandafter\noexpand\rng@LEP}}\tmp@exp
        \if\rng@isC@ntrol1% a control sequence
            \let\rng@CtrlLEP=1\let\rng@makeLEPStrict=1%
            \edef\tmp@exp{\noexpand%
                \@getVarType{\expandafter\noexpand\rng@LEP}}\tmp@exp
            \ifcase\varType % integer
                \defineQ{\rng@LEP}{\rng@LEP}{1}%
            \or % rational
                \edef\tmp@exp{\noexpand%
                \defineQ{\noexpand\rng@LEP}{\expandafter\nOf\rng@LEP}%
                    {\expandafter\dOf\rng@LEP}}\tmp@exp
            \or % real
                \defineR{\rng@LEP}{\rng@LEP}%
                \RNGparseDec{\rng@LEP}%
                \defineQ{\rng@LEP}{\rng@intpart}{\rng@fracpart}%
            \fi
        \else
            \RNGparseRat{\rng@LEP}%
            \defineQ{\rng@UEP}{\rng@intpart}{\rng@fracpart}%
        \fi
    \else
        \rng@isControl{#2}%
        \if\rng@isC@ntrol1% a control sequence
            \@getVarType{#2}%
            \ifcase\varType % integer
                \defineQ{\rng@LEP}{#2}{1}%
            \or % rational
                \defineQ{\rng@LEP}{\nOf{#2}}{\dOf{#2}}%
            \or % real
                \defineR{\rng@LEP}{#2}%
                \RNGparseDec{\rng@LEP}%
                \defineQ{\rng@LEP}{\rng@intpart}{\rng@fracpart}%
            \fi
        \else % a number, required to be rational
            \RNGparseRat{#2}%
            \defineQ{\rng@LEP}{\rng@num}{\rng@denom}%
        \fi
    \fi
    \rng@existStar{#3}\rng@NameEndpoint{\rng@UEP}%%
    \if\rng@isStariii*%
        \edef\tmp@exp{\noexpand%
            \rng@isControl{\expandafter\noexpand\rng@UEP}}\tmp@exp
        \if\rng@isC@ntrol1% a control sequence
            \let\rng@CtrlUEP=1\let\rng@makeUEPStrict=1%
            \edef\tmp@exp{\noexpand%
                \@getVarType{\expandafter\noexpand\rng@UEP}}\tmp@exp
            \ifcase\varType % integer
                \defineQ{\rng@UEP}{\rng@UEP}{1}%
            \or % rational
                \edef\tmp@exp{\noexpand%
                \defineQ{\noexpand\rng@UEP}{\expandafter\nOf\rng@UEP}%
                    {\expandafter\dOf\rng@UEP}}\tmp@exp
            \or % real
                \defineR{\rng@UEP}{\rng@UEP}%
                \RNGparseDec{\rng@UEP}%
                \defineQ{\rng@UEP}{\rng@intpart}{\rng@fracpart}%
            \fi
        \else
            \RNGparseRat{\rng@UEP}%
            \defineQ{\rng@UEP}{\rng@intpart}{\rng@fracpart}%
        \fi
    \else
        \rng@isControl{#3}%
        \if\rng@isC@ntrol1% a control sequence
            \@getVarType{#3}%
            \ifcase\varType % integer
                \defineQ{\rng@UEP}{#3}{1}%
            \or % rational
                \defineQ{\rng@UEP}{\nOf{#3}}{\dOf{#3}}%
            \or % real
                \defineR{\rng@UEP}{#3}%
                \RNGparseDec{\rng@UEP}%
                \defineQ{\rng@UEP}{\rng@intpart}{\rng@fracpart}%
            \fi
        \else % a number, required to be rational
            \RNGparseRat{#3}%
            \defineQ{\rng@UEP}{\rng@num}{\rng@denom}%
        \fi
    \fi
    \@@RandomQ{#1}{\nOf{\rng@LEP}}{\dOf{\rng@LEP}}%
        {\nOf{\rng@UEP}}{\dOf{\rng@UEP}}%
}
\newcommand{\@@RandomQ}[5]
{%
    \updateQ\@rqi{#2}{#3}\updateQ\@rqii{#4}{#5}%
    \lcm{#3}{#5}\edef\@thelcm{\thelcm}%
    \def\@maxDenom{#1}%
    \ifx\@maxDenom\@empty\edef\@maxDenom{\@thelcm}\else
        \lcm{\@thelcm}{#1}\edef\@thelcm{\thelcm}\fi
    \convertRatTo{\nOf\@rqi}{\dOf\@rqi}{\@thelcm}%
    \updateQ\@@rqi{\rng@retn@num}{\@thelcm}%
    \convertRatTo{\nOf\@rqii}{\dOf\@rqii}{\@thelcm}%
    \updateQ\@@rqii{\rng@retn@num}{\@thelcm}%
    \rng@cnta=\@thelcm \divide\rng@cnta by\@maxDenom
    \edef\@divisor{\the\rng@cnta}%
    \rng@cnta=\nOf\@@rqi
    \divide\rng@cnta by\@divisor
    \advance\rng@cnta by1
    \rng@cntb=\nOf\@@rqii\divide\rng@cntb by\@divisor
    \if\rng@makeLEPStrict1\advance\rng@cnta1\relax\fi
    \if\rng@makeUEPStrict1\advance\rng@cntb-1\relax\fi
    \expandafter\@getVarName\rq@currentName
    \let\save@varName\@varName
    \expandafter\edef\csname first@n@\@varName\endcsname{\the\rng@cnta}%
    \expandafter\edef\csname last@n@\@varName\endcsname{\the\rng@cntb}%
    \expandafter\edef\csname first@d@\@varName\endcsname{\@maxDenom}%
    \expandafter\edef\csname last@d@\@varName\endcsname{\@maxDenom}%
    \edef\rng@LEP{\csname first@n@\@varName\endcsname}%
    \edef\rng@UEP{\csname last@n@\@varName\endcsname}%
    \rng@chgrand[first=\rng@LEP,last=\rng@UEP]\rand
    \let\@currentName\rq@currentName
    \expandafter\@getVarName\rq@currentName
    \expandafter\defineQ\@currentName{\arabic{rand}}{\@maxDenom}%
    \simplifyCurrentQ
    \expandafter\defineQ\@currentName{\expandafter\nOf\@currentName}%
        {\expandafter\dOf\@currentName}%
    \ifx\rangen@ne\@empty\else\loopCnt=0\relax
        \@whilenum\loopCnt<\maxLoopLimit\do{%
            \rng@cnta=1\relax
            \@for\ne@@tmp:=\rangen@ne\do{%
                \let\save@currentName\rq@currentName
                \RNGparseRat{\ne@@tmp}%
                \defineQ{\cmp@Name}{\rng@num}{\rng@denom}%
                \let\@varName\save@varName
                \syncronizeQs{\@varName}%
                \ifnum\csname n@\@varName\endcsname=\n@cmp@Name
                    \multiply\rng@cnta0\relax
                \else
                    \multiply\rng@cnta1\relax
                \fi
            }%
            \ifnum\rng@cnta=1\relax % all conditions met
                \loopCnt=\maxLoopLimit
            \else % if \rng@cnta \ne 1, try again
                \advance\loopCnt1\relax
                \ifnum\loopCnt=\maxLoopLimit
                    \PackageWarning{rangen}{Not all conditions met
                        after \maxLoopLimit\space tries}%
                \else
                    \rng@chgrand[first=\rng@LEP,last=\rng@UEP]\rand
                    \expandafter\@getVarName\rq@currentName
                    \expandafter\defineQ\@currentName{\arabic{rand}}%
                        {\@maxDenom}%
                \fi
            \fi
        }%
    \fi
    \simplifyCurrentQ
    \expandafter\defineQ\@currentName{\expandafter\nOf\@currentName}%
        {\expandafter\dOf\@currentName}%
    \let\@currentName\rq@currentName
    \expandafter\@getVarName\rq@currentName
    \ifnum\csname d@\@varName\endcsname=1\relax\expandafter
        \defineZ\@currentName{\expandafter\nOf\@currentName}%
    \fi
    \simplifyCurrentQ
}
\newcommand\updateQ[3]
{%
    \@getVarName#1\relax
    \expandafter\edef\csname\@varName\endcsname{#2/#3}%
    \expandafter\edef\csname n@\@varName\endcsname{#2}%
    \expandafter\edef\csname d@\@varName\endcsname{#3}%
}
\def\simplifyCurrentQ
{%
    \reduceFrac{\csname n@\@varName\endcsname}%
        {\csname d@\@varName\endcsname}%
    \expandafter\edef\csname n@\@varName\endcsname{\rfNumer}%
    \expandafter\edef\csname d@\@varName\endcsname{\rfDenom}%
    \ifnum\csname n@\@varName\endcsname=0
        \expandafter\edef\csname\@varName\endcsname{0}%
        \edef\display@TeXfmt{0}\edef\inline@TeXfmt{0}%
    \else
       \ifnum\csname n@\@varName\endcsname=\csname d@\@varName\endcsname
            \expandafter\defineZ\csname\@varName\endcsname{1}%
       \else
            \ifnum\csname n@\@varName\endcsname
                =-\csname d@\@varName\endcsname
                \expandafter\defineZ\csname\@varName\endcsname{-1}%
            \else
                \ifnum\csname d@\@varName\endcsname=1
                    \expandafter\defineZ\csname\@varName\endcsname
                        {\csname n@\@varName\endcsname}%
                \else
                    \expandafter\edef\csname \@varName\endcsname{%
                    \csname n@\@varName\endcsname/%
                        \csname d@\@varName\endcsname}%
                    \edef\display@TeXfmt{%
                        \frac{\csname n@\@varName\endcsname}
                            {\csname d@\@varName\endcsname}}%
                    \edef\inline@TeXfmt{%
                        \csname n@\@varName\endcsname/%
                            \csname d@\@varName\endcsname}%
                    \expandafter\let
                    \csname\@varName*\endcsname\display@TeXfmt
                \fi
            \fi
        \fi
    \fi
}
\newcommand\nOf[1]{\csname n@\expandafter\@gobble\string#1\endcsname}
\newcommand\dOf[1]{\csname d@\expandafter\@gobble\string#1\endcsname}
\newcommand{\iOf}[1]{\csname i@\expandafter\@gobble\string#1\endcsname}
\newcommand\typeOf[1]{%
    \csname typeof@\expandafter\@gobble\string#1\endcsname}
\newif\iftrailingzeros\trailingzerosfalse
\@namedef{rng@tz1}{0}
\@namedef{rng@tz2}{00}
\@namedef{rng@tz3}{000}
\@namedef{rng@tz4}{0000}
\@namedef{rng@tz5}{00000}
\@namedef{rng@tz6}{000000}
\@namedef{rng@tz7}{0000000}
\@namedef{rng@tz8}{00000000}
\def\rng@true{true}\def\rng@false{false}
\newdimen\rng@dima
\newdimen\rng@dimb
\newdimen\rng@dimc
\define@key{rangen}{ne}[]{\edef\rangen@ne{#1}}
\define@key{rangen}{round}[]{\def\rangen@round{#1}}
\define@key{rangen}{showzeros}[]{\def\rangen@showzeros{#1}%
    \ifx\rangen@showzeros\@empty\global\trailingzerostrue\else
    \ifx\rangen@showzeros\rng@true\global\trailingzerostrue\else
    \global\trailingzerosfalse\fi\fi}
\define@key{rangen}{index}[]{\edef\rangen@index{#1}}
\newcommand{\RandomR}[4][]{%
     \setkeys{rangen}{ne,round,showzeros=false,#1}%
    \let\rng@CtrlLEP=0\let\rng@CtrlUEP=0%
    \let\rng@makeLEPStrict=0\let\rng@makeUEPStrict=0%
    \def\rng@lcg@first{0}\edef\rng@lcg@last{\RNGpowerOfTen}%
    \rng@existStar{#3}\rng@NameEndpoint{\rng@LEP}%
    \if\rng@isStariii*\edef\tmp@exp{\noexpand%
            \rng@isControl{\expandafter\noexpand\rng@LEP}}\tmp@exp
        \if\rng@isC@ntrol1% a control sequence
            \let\rng@CtrlLEP=1\let\rng@makeLEPStrict=1%
            \def\rng@lcg@first{1}%
            \edef\tmp@exp{\noexpand%
                \@getVarType{\expandafter\noexpand\rng@LEP}}\tmp@exp
            \ifcase\varType % integer
                \defineR{\rng@LEP}{\rng@LEP\RNG@Dec}%
            \or % rational
                \rng@dima=\expandafter\nOf\rng@LEP pt
                \divide\rng@dima by\expandafter\dOf\rng@LEP
                \defineR{\rng@LEP}{\strip@pt\rng@dima}%
            \or % real
                \defineR{\rng@LEP}{\rng@LEP}%
            \fi
        \else
            \defineR{\rng@LEP}{\rng@LEP}%
        \fi
    \else
        \rng@isControl{#3}%
        \if\rng@isC@ntrol1% control sequence
            \let\rng@CtrlLEP=1\def\rng@LEP{#3}%
            \@getVarType{#3}%
            \ifcase\varType % integer
                \defineR{\rng@LEP}{\rng@LEP\RNG@Dec}%
            \or % rational
                \rng@dima=\nOf{#3}pt
                \divide\rng@dima by\dOf{#3}%
                \defineR{\rng@LEP}{\strip@pt\rng@dima}%
            \or % real
                \defineR{\rng@LEP}{\rng@LEP}%
            \fi
        \else
            \defineR{\rng@LEP}{#3}%
        \fi
    \fi
    \rng@existStar{#4}\rng@NameEndpoint{\rng@UEP}%
    \if\rng@isStariii*\edef\tmp@exp{\noexpand%
            \rng@isControl{\expandafter\noexpand\rng@UEP}}\tmp@exp
        \if\rng@isC@ntrol1% a control sequence
            \let\rng@CtrlUEP=1\let\rng@makeUEPStrict=1%
            \rng@cnta=\rng@lcg@last\advance\rng@cnta-1\relax
            \edef\rng@lcg@last{\the\rng@cnta}%
            \edef\tmp@exp{\noexpand%
                \@getVarType{\expandafter\noexpand\rng@UEP}}\tmp@exp
            \ifcase\varType % integer
                \defineR{\rng@UEP}{\rng@UEP\RNG@Dec}%
            \or % rational
                \rng@dima=\expandafter\nOf\rng@UEP pt
                \divide\rng@dima by\expandafter\dOf\rng@UEP
                \defineR{\rng@UEP}{\strip@pt\rng@dima}%
            \or % real
                \defineR{\rng@UEP}{\rng@UEP}%
            \fi
        \else
            \defineR{\rng@UEP}{\rng@UEP}%
        \fi
    \else
        \rng@isControl{#4}%
        \if\rng@isC@ntrol1% control sequence
            \let\rng@CtrlUEP=1\def\rng@UEP{#4}%
            \@getVarType{#4}%
            \ifcase\varType % integer
                \defineR{\rng@UEP}{\rng@UEP\RNG@Dec}%
            \or % rational
                \rng@dima=\nOf{#4}pt
                \divide\rng@dima by\dOf{#4}%
                \defineR{\rng@UEP}{\strip@pt\rng@dima}%
            \or % real
                \defineR{\rng@UEP}{\rng@UEP}%
            \fi
        \else
            \defineR{\rng@UEP}{#4}%
        \fi
    \fi
    \def\@currentName{#2}\@getVarName{#2}%
    \expandafter\edef\csname first@\@varName\endcsname{\rng@LEP}%
    \expandafter\edef\csname last@\@varName\endcsname{\rng@UEP}%
    \rng@getRandomR
    \defineR{#2}{\strip@pt\rng@dima}%
    \ifx\rangen@round\@empty\else
        \RNGround{#2}{#2}{\rangen@round}%
        \rng@dima=#2pt\relax
        \defineR{#2}{\strip@pt\rng@dima}%
    \fi
    \ifx\rangen@ne\@empty\else\loopCnt=0\relax
        \@whilenum\loopCnt<\maxLoopLimit\do{%
            \rng@cnta=1\relax
            \@for\ne@@tmp:=\rangen@ne\do{%
                \rng@dima=#2pt
                \ifdim\rng@dima=\ne@@tmp pt\relax
                \multiply\rng@cnta0\relax\else
                \multiply\rng@cnta1\relax\fi
            }%
            \ifnum\rng@cnta=1\relax % all conditions met
                \loopCnt=\maxLoopLimit
            \else % if \rng@cnta \ne 1, try again
                \advance\loopCnt1\relax
                \ifnum\loopCnt=\maxLoopLimit
                    \PackageWarning{rangen}{Not all conditions met
                        after \maxLoopLimit\space tries}%
                \else
                    \rng@getRandomR
                    \defineR{#2}{\strip@pt\rng@dima}%
                    \ifx\rangen@round\@empty\else
                        \RNGround{#2}{#2}{\rangen@round}%
                        \rng@dima=#2pt\relax
                        \defineR{#2}{\strip@pt\rng@dima}%
                    \fi
                \fi
            \fi
        }%
    \fi
    \rnd@ProcessRealFormat{#2}%
    \def\@currentName{#2}%
    \defineR{#2}{#2}%
}
\def\rng@getRandomR{%
    \rng@dima=\rng@LEP pt
    \rng@dimb=\rng@UEP pt
    \advance\rng@dimb-\rng@dima
    \rng@chgrand[first=\rng@lcg@first,last=\rng@lcg@last]\rand
    \divide\rng@dimb by\RNGpowerOfTen\relax
    \rng@dimb=\arabic{rand}\rng@dimb
    \advance\rng@dima by\rng@dimb
}
\def\rnd@ProcessRealFormat#1{%
    \ifx\rangen@round\@empty
        \rng@dima=#1pt\relax
        \defineR{#1}{\strip@pt\rng@dima}%
    \else
        \RNGround{#1}{#1}{\rangen@round}%
        \rng@dima=#1pt\relax
        \defineR{#1}{\strip@pt\rng@dima}%
        \iftrailingzeros
            {\RNGparseDec{#1}\count0=\decPls\relax
             \advance\count0-\rndnDec\relax
             \ifnum\count0>0\relax\xdef#1{%
                \rng@intpart\RNG@Dec\rng@fracpart%
\@nameuse{rng@tz\the\count0}}%
             \fi}%
             \defineR{#1}{#1}%
        \fi
    \fi
}
\newcommand{\RandomS}[2][1/2]{%
    \RNGparseRat{#1}%
    \ifnum\rng@num<0\relax
        \PackageError{rangen}{A positive numerator is required}%
        {The rational number must be between 0 and 1}\fi
    \ifnum\rng@denom<0\relax
    \PackageError{rangen}{A positive denominator is required}%
    {The rational number must be between 0 and 1}\fi
    \ifnum\rng@num>\rng@denom\relax
    \PackageError{rangen}{The rational must be between 0 and 1}%
    {The rational number must be between 0 and 1}\fi
    \rng@chgrand[first=1,last=\rng@denom]\rand
    \@getVarName{#2}%
    \ifnum\value{rand}>\rng@num\relax\def#2{-}%
    \rng@makeMinusOneFmtDefns
    \def\display@TeXfmt{-}\def\inline@TeXfmt{-}%
    \else\def#2{+}\rng@makeOneFmtDefns
    \def\display@TeXfmt{}\def\inline@TeXfmt{}\fi
    \expandafter\let\csname\@varName*\endcsname\display@TeXfmt
    \expandafter\let\csname\@varName!\endcsname\inline@TeXfmt
}
\newcommand{\RandomL}[3][]{%
    \let\rangen@index\@empty
    \setkeys{rangen}{#1}%
    \rng@cnta=0\relax\@for\@@tmp:=#3\do{%
    \advance\rng@cnta1\relax}\edef\n@rng@listItems{\the\rng@cnta}%
    \ifx\rangen@index\@empty
        \rng@chgrand[first=1,last=\n@rng@listItems]\rand
    \else
        \rng@cnta=\rangen@index
        \advance\rng@cnta-1\relax
        \amodb{\rng@cnta}{\n@rng@listItems}%
        \rng@cnta=\retnmod
        \advance\rng@cnta1\relax
        \value{rand}=\rng@cnta
    \fi
    \@getVarName{#2}%
    \expandafter\edef\csname i@\@varName\endcsname{\arabic{rand}}%
    \rng@cnta=0\relax\@for\@@tmp:=#3\do{%
    \advance\rng@cnta1\relax\ifnum\rng@cnta=\arabic{rand}%
    \edef\rng@choice{\@@tmp}\fi}%
    \def\@currentName{#2}%
    \RNGparseDec{\rng@choice}%
    \if\rng@parseR@iii\RNG@Dec\defineR{#2}{\rng@choice}%
    \else\RNGparseRat{\rng@choice}%
    \if\rng@parseQ@iii/\defineQ{#2}{\rng@num}{\rng@denom}%
    \else\defineZ{#2}{\rng@choice}\fi\fi
}

\newcommand{\RandomP}[3][]{%
    \let\rangen@index\@empty
    \setkeys{rangen}{#1}%
    \rng@cnta=0\relax\@for\@@tmp:=#3\do{%
    \advance\rng@cnta1\relax}\edef\n@rng@listItems{\the\rng@cnta}%
    \ifx\rangen@index\@empty
        \rng@chgrand[first=1,last=\n@rng@listItems]\rand
    \else
        \rng@cnta=\rangen@index
        \advance\rng@cnta-1\relax
        \amodb{\rng@cnta}{\n@rng@listItems}%
        \rng@cnta=\retnmod
        \advance\rng@cnta1\relax
        \value{rand}=\rng@cnta
    \fi
    \@getVarName{#2}%
    \expandafter\edef\csname i@\@varName\endcsname{\arabic{rand}}%
    \rng@cnta=0\relax\@for\@@tmp:=#3\do{%
    \advance\rng@cnta1\relax\ifnum\rng@cnta=\arabic{rand}%
    \rng@toks=\expandafter{\@@tmp}\edef#2{\the\rng@toks}%
    \expandafter\def\csname typeof@\@varName\endcsname{3}\fi}%
}
\newcommand{\RandomI}[2]{%
    \rng@chgrand[first=1,last=#2]\rand
    \defineZ{#1}{\arabic{rand}}%
    \expandafter\edef\csname i@\@varName\endcsname{\arabic{rand}}%
}
\defineZ{\zZero}{0}
\defineZ{\zOne}{1}
\defineZ{\zMinusOne}{-1}
\defineR{\rPI}{3.1415927}
\defineR{\rE}{2.7182818}
\def\syncronizeQs#1{\edef\sync@arg{#1}%
    \lcm{\csname d@\sync@arg\endcsname}{\d@cmp@Name}%
    \edef\@thelcm{\thelcm}%
    \convertRatTo{\n@cmp@Name}{\d@cmp@Name}{\@thelcm}%
    \updateQ\cmp@Name{\rng@retn@num}{\@thelcm}%
    \convertRatTo{\csname n@\sync@arg\endcsname}%
        {\csname d@\sync@arg\endcsname}{\@thelcm}\expandafter
    \defineQ\csname\sync@arg\endcsname{\rng@retn@num}{\@thelcm}%
}
\newcommand\ds[1]{%
    \expandafter\csname\expandafter\@gobble\string#1*\endcsname
}
\newcommand\eds[1]{%
    \expandafter\csname\expandafter\@gobble\string#1*e\endcsname
}
\newcommand\cds[1]{%
    \expandafter\csname\expandafter\@gobble\string#1*c\endcsname
}
\newcommand\fmt[1]{%
    \expandafter\csname\expandafter\@gobble\string#1!\endcsname
}
\newcommand\efmt[1]{%
    \expandafter\csname\expandafter\@gobble\string#1!e\endcsname
}
\newcommand\cfmt[1]{%
    \expandafter\csname\expandafter\@gobble\string#1!c\endcsname
}
\newcommand\js[1]{%
    \expandafter\csname\expandafter\@gobble\string#1!*\endcsname
}

\def\RNGround#1#2#3{%
    \begingroup
    \def\rng@ctrlName{#1}%
    \def\rng@sourceName{#2}%
    \def\rng@nDecPl{#3}%
    \RNGparseDec{#2}%
    \ifnum\rndnDec<#3\relax
        \xdef\theseDigits{\rng@fracpart}%
        \let\rng@next\relax
    \else
        \count0=0\relax
        \gdef\theseDigits{}%
        \def\rng@next{\expandafter\@rng@round\rng@fracpart\end}%
    \fi
    \rng@next
    \xdef\decPls{\@ifundefined{save@rng@nDecPl}%
        {\rng@nDecPl}{\save@rng@nDecPl}}%
    \ifx\theseDigits\@empty
    \xdef#1{\rng@intpart}\else
    \xdef#1{\rng@intpart\RNG@Dec\theseDigits}\fi
    \endgroup
}
\def\@rng@round#1{%
    \ifx#1\end\let\rng@next\relax
    \else
        \ifnum\rng@nDecPl=0\relax
            \ifnum#1>4\relax
                \count0=\rng@intpart\relax
                \ifnum\rng@intpart<0\relax
                    \advance\count0by-1\relax
                \else
                    \advance\count0by1\relax
                \fi
                \xdef\rng@intpart{\the\count0}%
            \fi
            \gdef\theseDigits{}%
            \let\rng@next\rng@gobbletoend
        \else
            \advance\count0by1\relax
            \ifnum\count0=\rng@nDecPl\relax
                \def\rng@next{\@@rng@round#1}%
            \else
                \xdef\theseDigits{\theseDigits#1}%
                \let\rng@next\@rng@round
            \fi
        \fi
    \fi
    \rng@next
}
\def\rng@gobbletoend#1\end{}
\def\@@rng@round#1#2{%
    \ifx#2\end%
        \xdef\theseDigits{\theseDigits#1}%
        \let\rng@next\relax
    \else
        \ifnum#2>4\relax\count2=#1\relax
            \ifnum\count2=9\relax
                \count0=\rng@nDecPl\relax
                \ifnum\count0=1\relax
                    \count0=\rng@intpart\relax
                    \ifnum\rng@intpart<0\relax
                        \advance\count0by-1\relax
                    \else
                        \advance\count0by1\relax
                    \fi
                    \xdef\rng@intpart{\the\count0}%
                    \let\rng@next\rng@gobbletoend
                \else
                    \advance\count0by-1\relax\expandafter
                    \xdef\rng@sourceName{%
                        \rng@intpart\RNG@Dec\theseDigits#1}%
                    \edef\save@rng@nDecPl{\rng@nDecPl}%
                    \edef\rng@next{\noexpand\RNGround{%
                        \expandafter\noexpand\rng@ctrlName}%
                        {\expandafter\noexpand\rng@sourceName}%
                        {\the\count0}\noexpand\rng@gobbletoend}%
                \fi
            \else
                \advance\count2by1\relax
                \xdef\theseDigits{\theseDigits\the\count2}%
                \let\rng@next\rng@gobbletoend
            \fi
        \else % \ifnum#2<=4
            \xdef\theseDigits{\theseDigits#1}%
            \let\rng@next\rng@gobbletoend
        \fi
    \fi
    \rng@next
}
\def\RNGprintf#1{("#1",\@gobble}
\newcommand\defineDepQJS[4]{%
    \@getVarName#1
    \expandafter\edef\csname\@varName\endcsname{(#2)/(#3)}%
    \expandafter\edef\csname n@\@varName\endcsname{(#2)}%
    \expandafter\edef\csname d@\@varName\endcsname{(#3)}%
    \edef\display@TeXfmt{\csname\@varName\endcsname}%
    \edef\inline@TeXfmt{\csname\@varName\endcsname}%
    \def\dv@argiv{#4}\ifx\dv@argiv\@empty
    \edef\eval@JSfmt{\csname\@varName\endcsname}\else
    \edef\eval@JSfmt{#4}\fi
    \expandafter\let\csname\@varName!*\endcsname\eval@JSfmt
}
\def\rng@writeCurrentSeed#1{\immediate\write#1{\string\makeatletter
    \string\global\string\cr@nd=\the\cr@nd\string\relax
    \string\makeatother}}
\newtoks\rng@toks
\def\wrv@ex@solns{exercises}%
\def\wrv@ex@quiz{quizzes}%
\newenvironment{writeRVsTo}[2][]
{%
    \def\wrv@argii{#2}%
    \ifx\wrv@argii\wrv@ex@quiz\let\wrv@out\quiz@solns
    \else\ifx\wrv@argii\wrv@ex@solns\let\wrv@out\ex@solns\else
    \let\wrv@out#2\fi\fi
    \rng@writeCurrentSeed\wrv@out
    \rng@toks={}%
    \def\verbatim@processline{%
        \xdef\rng@temp{\the\rng@toks\the\verbatim@line}%
        \global\rng@toks=\expandafter{\rng@temp}}%
    \let\do\@makeother\dospecials\catcode`\^^M\active
    #1%
    \verbatim@start
}{  \immediate\write\wrv@out{\the\rng@toks}%
    \newwrite\rng@writeRVs
    \immediate\openout\rng@writeRVs\jobname_rvs.cut
    \immediate\write\rng@writeRVs{\the\rng@toks}%
    \immediate\closeout\rng@writeRVs
    \aftergroup\rng@Input@RVs
}
\def\rng@Input@RVs{\InputIfFileExists{\jobname_rvs.cut}{}{}}
\def\rng@p@stkeysr@nd{%
   \@rderr@nd%                  last < first  -> swap
   \cutr@nger@nd%               range too big -> cut
} % end of \def\p@stkeysr@nd
\def\rng@chgrand{\@ifnextchar[\rng@chgr@nd{\rng@chgr@nd[]}}
\def\rng@chgr@nd[#1]{%
    \@tempcnta=\z@
    \@tempcntb=\z@
    \setkeys{Init}{#1}%
    \rng@p@stkeysr@nd%
    \@utputr@nd%
}  % end of \def\rng@chgrand
\begin{insDLJS}[partialExpand]{partial}{Rangen}
var partre = /rEval|rFrac/;
function rngCorrAnsButton()
{
    var theprecision,fieldname,theanswer;
    if (arguments.length==4) {
        var theformat=arguments[0];
        var fieldname=arguments[1];
        var theanswer=arguments[2];
        var thequiz=arguments[3];
    } else {
        var fieldname=arguments[0];
        var theanswer=arguments[1];
        var thequiz=arguments[2];
    }
    theanswer = partialExpand(0,theanswer);
    if (arguments.length==4)
        theanswer=util.printf(theformat,eval(theanswer));
    DisplayAnswer(fieldname,theanswer,thequiz);
}
function partialExpand(level,Ans)
{
    Ans = correctPlusMinus(Ans)
    level += 1;
\db console.println("Enter level = " + level +": Ans: " + Ans);\db%
    var n=0, m, bP, eP, subExp;
    while ( true ) {
\db     console.println("Searching a level " + level);\db%
        try { m = Ans.match(partre); }
        catch (e) { break; }
        if ( m != null ) {
            bP = m.index + m[0].length;
            eP = FindBalP(Ans, bP, true);
\db         console.println("bP = " + bP + " : eP = " + eP);\db%
            var subExp = Ans.substring(bP+1, eP);
\db         console.println("Found \'" + subExp%
                + "\' at level = " + level);\db%
            // n = beginning of "rEval",
            // eP = beginning of balanced parens,
            // bP = end of balanced parens
            Ans = Ans.substring(0, m.index)
                + eval(m[0]+"(level,subExp)") + Ans.substring(eP+1);
\db         console.println("level = " + level%
                             +": New Ans: " + Ans);\db %
        } else {
            if ( level == 1 ) {
\db             console.println("Level 1 break");\db %
                break;
            }
        }
    }
\db console.println("Return Ans: " + Ans);\db%
    Ans = correctPlusMinus(Ans);
    return Ans;
}
function rEval(level, Ans)
{
    level += 1;
\db console.println("Enter rEval: level = "%
        + level +": Ans: " + Ans);\db%
    var n=0, m, bP, eP, subExp;
    while ( true )
    {
\db     console.println("Searching a level " + level);\db%
        try { m = Ans.match(partre); }
        catch (e) { break; }
        if ( m != null ) {
            bP = m.index + m[0].length;
            eP = FindBalP(Ans, bP, true);
\db         console.println("bP = " + bP + " : eP = " + eP);\db%
            var subExp = Ans.substring(bP+1, eP);
\db         console.println("Found \'" + subExp%
                + "\' at level = " + level);\db%
            // n = beginning of "rEval",
            // eP = beginning of balanced parens,
            // bP = end of balanced parens
            Ans = Ans.substring(0, m.index)
                +eval(m[0]+"(level,subExp)")+Ans.substring(eP+1);
\db         console.println("level = "%
                + level +": New Ans: " + Ans);\db %
        } else {
            Ans = ParseInput(Ans);
\db         console.println("Ready to eval at level = "%
                + level + ": Ans = " + Ans);\db%
            with(Math) { Ans = eval( Ans ) };
\db         console.println("After eval at level = "%
                + level + ": Ans = " + Ans);\db%
            break;
        }
    }
\db console.println("Return Ans: " + Ans);\db%
    return Ans;
}
function rFrac(level, Ans)
{
    level += 1;
\db console.println("Enter rFrac level = "%
        + level +": Ans: " + Ans);\db%
    var n=0, m, bP, eP, subExp;
    while ( true ) {
\db     console.println("Searching a level " + level);\db%
        try { m = Ans.match(partre); }
        catch (e) { break; }
        if ( m != null ) {
            bP = m.index + m[0].length;
            eP = FindBalP(Ans, bP, true);
\db         console.println("bP = "%
                + bP + " : eP = " + eP);\db%
            var subExp = Ans.substring(bP+1, eP);
\db         console.println("Found \'" + subExp%
                + "\' at level = " + level);\db%
            // n = beginning of "rEval",
            // eP = beginning of balanced parens,
            // bP = end of balanced parens
            Ans = Ans.substring(0, m.index)
                + eval(m[0]+"(level,subExp)") + Ans.substring(eP+1);
\db         console.println("level = " + level%
                +": New Ans: " + Ans);\db %
        } else {
            var numDenom = Ans.split("/");
            numDenom[0] = eval(numDenom[0]);
            numDenom[1] = eval(numDenom[1]);
            var g = gcd(numDenom[0], numDenom[1]);
            numDenom[0] /= g;
            numDenom[1] /= g;
            if ( numDenom[1] == 1)
                Ans = numDenom[0];
            else
                Ans = numDenom.join("/");
\db         console.println("Reduce: " + numDenom.join("/"));\db%
            break;
        }
    }
\db console.println("Return Ans: " + Ans);\db%
    return Ans;
}
function correctPlusMinus(Ans)
{
    Ans = "" + Ans;
    Ans  = Ans.replace(/\s*([\+-])\s*\1\s*/g, " + ");
    Ans  = Ans.replace(/\s*\+\s*-\s*/g, " - ");
    Ans  = Ans.replace(/\s*-\s*\+\s*/g, " - ");
    return Ans;
}
function gcd(a,b)
{
    var x = a, y = b, r;
    while (true)
    {
        r = x \% y;
        if ( r == 0 ) break;
        x = y;
        y = r;
    }
    return Math.abs(y);
}
function lcm (a,b) { return (a*b)/gcd(a,b); }
\end{insDLJS}
\endinput
%%
%% End of file `rangen.sty'.
